{"meta":{"title":"权小爷的QQ空间","subtitle":null,"description":null,"author":"木又","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Lua学习笔记——时间和日期","slug":"Lua学习笔记——日期和时间","date":"2019-10-08T11:22:00.000Z","updated":"2019-10-08T12:22:50.390Z","comments":true,"path":"2019/10/08/Lua学习笔记——日期和时间/","link":"","permalink":"http://yoursite.com/2019/10/08/Lua学习笔记——日期和时间/","excerpt":"","text":"思维导图首先我们看一张思维导图： 备注： 1. 纪元：一个固定日期，在 POSIX 和 Windows 平台中这个固定日期是 Jan 01, 1970, 00:00 UTC。 2. 日期表：在 lua 中表示时间的一种方式，这个表具有以下几个重要字段：year、month、day、hour、 min、sec、wday、yday、isdst。 wday：本周中的第几天（第一天是星期日） yday：当年中的第几天 isdst：布尔类型。如果使用夏令时则为真。 例如：Sep 16,1998,23:48:10 用日期表的格式表示为：{year=1998, month=9, day=16, yday=259, wday=4, hour=23, min=48, sec=10, isdst=false} 日期表中各个参数的范围如下：（秒的最大范围是60，允许闰秒的存在。） 字段 范围 year 一整年 month 1~12 day 1~31 hour 0~23 min 0~59 sec 0~60 wday 1~7 yday 1~366 3. os.clock()：在性能测试中，可用来记录程序的运行时间。如下： 123local x = os.clock()-- do somethingprint(os.clock() - x) 实际使用1. 获取当前时间的整数表达12-- 当前时间为 2019-10-8 19:00:00print(os.time()) -- 1570532400 2. 获取当前时间的格式化表示12-- 当前时间为 2019-10-8 19:00:00print(os.date()) -- Tue Oct 8 19:00:00 2019 3. 获取指定天数之后的日期下面我们先看一个计算当前天数 40 天之后的日期的例子： 123456789101112-- 当前时间为 2019-10-8 19:00:00t = os.date(\"*t\") -- 获取当前日期print(os.date(\"%Y/%m/%d\", os.time(t))) -- 2019-10-8print(t.day, t.month) -- 8 10t.day = t.day + 40print(t.day, t.month) -- 48 10print(os.date(\"%Y/%m/%d\", os.time(t))) -- 2019-11-17 (归一化)t = os.date(\"*t\", os.time(t))print(t.day, t.month) -- 17 11 -- 2019-11-17 (归一化)t.month = t.month + 1print(t.day, t.month) -- 17 12print(os.date(\"%Y/%m/%d\", os.time(t))) -- 2019-12-17 在上面的例子中，我们看到，在加完天数之后，我们先将我们的日期表使用 os.time() 转换成整数，然后再用 os.date() 就可以做到日期的归一化显示。","categories":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/categories/Lua程序设计/"}],"tags":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/tags/Lua程序设计/"}]},{"title":"Unity中查找静态引用指定图片的预制体","slug":"Unity中查找静态引用指定图片的预制体","date":"2019-09-16T03:07:42.000Z","updated":"2019-09-16T03:09:20.840Z","comments":true,"path":"2019/09/16/Unity中查找静态引用指定图片的预制体/","link":"","permalink":"http://yoursite.com/2019/09/16/Unity中查找静态引用指定图片的预制体/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using UnityEditor;using UnityEngine;using System.Collections.Generic;using System.IO;public class SearchRefrenceEditorWindow : EditorWindow&#123; /// &lt;summary&gt; /// 查找引用 /// &lt;/summary&gt; [MenuItem(&quot;Assets/SearchRefrence&quot;)] static void SearchRefrence() &#123; SearchRefrenceEditorWindow window = (SearchRefrenceEditorWindow)EditorWindow.GetWindow(typeof(SearchRefrenceEditorWindow), false, &quot;Searching&quot;, true); window.Show(); &#125; private static Object searchObject; private List&lt;Object&gt; result = new List&lt;Object&gt;(); private void OnGUI() &#123; EditorGUILayout.BeginHorizontal(); searchObject = EditorGUILayout.ObjectField(searchObject, typeof(Object), true, GUILayout.Width(200)); if (GUILayout.Button(&quot;Search&quot;, GUILayout.Width(100))) &#123; result.Clear(); if (searchObject == null) return; string assetPath = AssetDatabase.GetAssetPath(searchObject); string assetGuid = AssetDatabase.AssetPathToGUID(assetPath); //只检查prefab string[] guids = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, new[] &#123; &quot;Assets/Res/GUI/prefabs&quot; &#125;); float length = guids.Length; for (int i = 0; i &lt; length; i++) &#123; string filePath = AssetDatabase.GUIDToAssetPath(guids[i]); if (EditorUtility.DisplayCancelableProgressBar(&quot;Checking&quot;, filePath, i / length)) &#123; break; &#125; //检查是否包含guid string content = File.ReadAllText(filePath); if (content.Contains(assetGuid)) &#123; Object fileObject = AssetDatabase.LoadAssetAtPath(filePath, typeof(Object)); result.Add(fileObject); &#125; &#125; EditorUtility.ClearProgressBar(); &#125; EditorGUILayout.EndHorizontal(); //显示结果 EditorGUILayout.BeginVertical(); for (int i = 0; i &lt; result.Count; i++) &#123; EditorGUILayout.ObjectField(result[i], typeof(Object), true, GUILayout.Width(300)); &#125; EditorGUILayout.EndHorizontal(); &#125;&#125;","categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/categories/效率工具/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/tags/效率工具/"}]},{"title":"Lua学习笔记——闭包","slug":"Lua学习笔记——闭包","date":"2019-09-16T02:57:25.000Z","updated":"2019-10-08T11:22:27.972Z","comments":true,"path":"2019/09/16/Lua学习笔记——闭包/","link":"","permalink":"http://yoursite.com/2019/09/16/Lua学习笔记——闭包/","excerpt":"","text":"前言在解释闭包之前，我们先要介绍下下面几个概念。 非局部变量（UpValue） 词法定界 1. 非局部变量（UpValue）定义： 不在局部范围内定义的非全局变量。 在下面的那段代码中，变量 a 既不是函数 B( ) 的局部变量，也不是全局变量，我们称 a 是函数 B( ) 的非局部变量（即 UpValue）。 1234567function A() local a = &#123;&#125; function B() local b = a endend 2. 词法定界定义： 被嵌套的函数可以访问他外部函数中的变量。 如上面那段代码所示，正是因为词法定界的存在，我们才可以在函数 B( ) 中，访问到函数 A( ) 中的局部变量 a。 闭包定义： 一个闭包就是由该函数和与其相关的引用环境所组成的实体。闭包 = 函数 + 引用环境。 在上面的代码中，函数 A( ) 就是一个闭包，函数 B( ) 和其引用的 变量a 也是一个闭包。 我们再来看下下面这段代码 1234567function newCounter() local count = 0 return function() count = count + 1 return count endend 在上述这段代码中，函数 newCounter( ) 返回了一个匿名函数，该匿名函数又调用了 非局部变量count， 当我们调用这个函数之后，会返回一个闭包，这个闭包由该匿名函数和 非局部变量count 组成，每调用一次返回的匿名函数，count 的值都会加 1。效果如下所示 123local c1 = newCounter()c1() --&gt; 1c1() --&gt; 2 这个时候，如果我们再次调用方法 newCounter( )， 就会创建一个新的闭包。效果如下： 12345local c2 = newCounter()c2() --&gt; 1c1() --&gt; 3c2() --&gt; 2c2() --&gt; 3 总结： 闭包 = 函数 + 引用环境。 每一个闭包都是一个独立的互不干扰的个体。 从技术上讲，lua 语言只有闭包没有函数，函数本身只是闭包的一种原型。","categories":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/categories/Lua程序设计/"}],"tags":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/tags/Lua程序设计/"}]},{"title":"策略模式","slug":"策略模式","date":"2019-07-16T03:10:53.000Z","updated":"2019-07-18T11:04:15.499Z","comments":true,"path":"2019/07/16/策略模式/","link":"","permalink":"http://yoursite.com/2019/07/16/策略模式/","excerpt":"","text":"1. 什么是策略模式？策略模式定义了算法族，将它们分别封装起来，让它们可以相互替换。这个模式使算法独立于它的使用者。 譬如我们我们需要实现一个计算器的功能，这个计算器有加减乘除四种计算方式，一般的做法就是创建一个计算器类，然后在这个类中添加加减乘除四个方法。代码如下： 1234567public class Calculator&#123; public int Add(int num1, int num2)&#123;return num1+num2;&#125; public int Sub(int num1, int num2)&#123;return num1-num2;&#125; public int Mul(int num1, int num2)&#123;return num1*num2;&#125; public int Div(int num1, int num2)&#123;return num1/num2;&#125;&#125; 策略模式是将加减乘除分别定义成一个单独的类，当我们使用计算器的时候，动态的替换我们当前使用的算法，具体代码如下： 12345678910111213141516171819202122232425262728public interface Operation&#123; public int Operate(int num1, int num2);&#125;public class AddOperation:Operation&#123; public int Operate(int num1, int num2)&#123;return num1 + num2;&#125;&#125;public class SubOperation:Operation&#123; public int Operate(int num1, int num2)&#123;return num1 - num2;&#125;&#125;public class Calculator&#123; private Operation _curOperation; public void SetOperation(Operation o)&#123;_curOperation = o;&#125; public int Operate(int num1, num2)&#123;return _curOperation.Operate(num1, num2)&#125;&#125;// 使用方法Calculator c = new Calculator();c.SetOperation(new AddOperation());c.Operate(2, 1); // 输出 3c.SetOperation(new SubOperation());c.Operate(2, 1); // 输出 1 策略模式让我们的代码更容易扩展，如果以后需要添加其他的算法，只需要再增加一个新的类，然后实现Operation接口，不需要改动之前的任何代码。 2. 设计模式的优缺点优点： ​ 1. 遵守了开放封闭原则。扩展性良好 缺点： 策略越多，类也就会越多。 所有的算法都应该暴露出去，并且写好文档，让别人知道你已经提供了哪些策略。 ​","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"http://yoursite.com/tags/策略模式/"}]}]}