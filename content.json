{"meta":{"title":"权小爷的QQ空间","subtitle":null,"description":null,"author":"木又","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Unity中查找静态引用指定图片的预制体","slug":"Unity中查找静态引用指定图片的预制体","date":"2019-09-16T03:07:42.000Z","updated":"2019-09-16T03:09:20.840Z","comments":true,"path":"2019/09/16/Unity中查找静态引用指定图片的预制体/","link":"","permalink":"http://yoursite.com/2019/09/16/Unity中查找静态引用指定图片的预制体/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using UnityEditor;using UnityEngine;using System.Collections.Generic;using System.IO;public class SearchRefrenceEditorWindow : EditorWindow&#123; /// &lt;summary&gt; /// 查找引用 /// &lt;/summary&gt; [MenuItem(\"Assets/SearchRefrence\")] static void SearchRefrence() &#123; SearchRefrenceEditorWindow window = (SearchRefrenceEditorWindow)EditorWindow.GetWindow(typeof(SearchRefrenceEditorWindow), false, \"Searching\", true); window.Show(); &#125; private static Object searchObject; private List&lt;Object&gt; result = new List&lt;Object&gt;(); private void OnGUI() &#123; EditorGUILayout.BeginHorizontal(); searchObject = EditorGUILayout.ObjectField(searchObject, typeof(Object), true, GUILayout.Width(200)); if (GUILayout.Button(\"Search\", GUILayout.Width(100))) &#123; result.Clear(); if (searchObject == null) return; string assetPath = AssetDatabase.GetAssetPath(searchObject); string assetGuid = AssetDatabase.AssetPathToGUID(assetPath); //只检查prefab string[] guids = AssetDatabase.FindAssets(\"t:Prefab\", new[] &#123; \"Assets/Res/GUI/prefabs\" &#125;); float length = guids.Length; for (int i = 0; i &lt; length; i++) &#123; string filePath = AssetDatabase.GUIDToAssetPath(guids[i]); if (EditorUtility.DisplayCancelableProgressBar(\"Checking\", filePath, i / length)) &#123; break; &#125; //检查是否包含guid string content = File.ReadAllText(filePath); if (content.Contains(assetGuid)) &#123; Object fileObject = AssetDatabase.LoadAssetAtPath(filePath, typeof(Object)); result.Add(fileObject); &#125; &#125; EditorUtility.ClearProgressBar(); &#125; EditorGUILayout.EndHorizontal(); //显示结果 EditorGUILayout.BeginVertical(); for (int i = 0; i &lt; result.Count; i++) &#123; EditorGUILayout.ObjectField(result[i], typeof(Object), true, GUILayout.Width(300)); &#125; EditorGUILayout.EndHorizontal(); &#125;&#125;","categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/categories/效率工具/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/tags/效率工具/"}]},{"title":"Lua闭包","slug":"Lua闭包","date":"2019-09-16T02:57:25.000Z","updated":"2019-09-16T03:09:23.705Z","comments":true,"path":"2019/09/16/Lua闭包/","link":"","permalink":"http://yoursite.com/2019/09/16/Lua闭包/","excerpt":"","text":"前言在解释闭包之前，我们先要介绍下下面几个概念。 第一类值 词法定界 非局部变量","categories":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/categories/Lua程序设计/"}],"tags":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/tags/Lua程序设计/"}]},{"title":"策略模式","slug":"策略模式","date":"2019-07-16T03:10:53.000Z","updated":"2019-07-18T11:04:15.499Z","comments":true,"path":"2019/07/16/策略模式/","link":"","permalink":"http://yoursite.com/2019/07/16/策略模式/","excerpt":"","text":"1. 什么是策略模式？策略模式定义了算法族，将它们分别封装起来，让它们可以相互替换。这个模式使算法独立于它的使用者。 譬如我们我们需要实现一个计算器的功能，这个计算器有加减乘除四种计算方式，一般的做法就是创建一个计算器类，然后在这个类中添加加减乘除四个方法。代码如下： 1234567public class Calculator&#123; public int Add(int num1, int num2)&#123;return num1+num2;&#125; public int Sub(int num1, int num2)&#123;return num1-num2;&#125; public int Mul(int num1, int num2)&#123;return num1*num2;&#125; public int Div(int num1, int num2)&#123;return num1/num2;&#125;&#125; 策略模式是将加减乘除分别定义成一个单独的类，当我们使用计算器的时候，动态的替换我们当前使用的算法，具体代码如下： 12345678910111213141516171819202122232425262728public interface Operation&#123; public int Operate(int num1, int num2);&#125;public class AddOperation:Operation&#123; public int Operate(int num1, int num2)&#123;return num1 + num2;&#125;&#125;public class SubOperation:Operation&#123; public int Operate(int num1, int num2)&#123;return num1 - num2;&#125;&#125;public class Calculator&#123; private Operation _curOperation; public void SetOperation(Operation o)&#123;_curOperation = o;&#125; public int Operate(int num1, num2)&#123;return _curOperation.Operate(num1, num2)&#125;&#125;// 使用方法Calculator c = new Calculator();c.SetOperation(new AddOperation());c.Operate(2, 1); // 输出 3c.SetOperation(new SubOperation());c.Operate(2, 1); // 输出 1 策略模式让我们的代码更容易扩展，如果以后需要添加其他的算法，只需要再增加一个新的类，然后实现Operation接口，不需要改动之前的任何代码。 2. 设计模式的优缺点优点： ​ 1. 遵守了开放封闭原则。扩展性良好 缺点： 策略越多，类也就会越多。 所有的算法都应该暴露出去，并且写好文档，让别人知道你已经提供了哪些策略。 ​","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"http://yoursite.com/tags/策略模式/"}]}]}