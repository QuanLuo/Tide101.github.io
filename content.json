{"meta":{"title":"权小爷的QQ空间","subtitle":null,"description":null,"author":"木又","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Lua学习笔记——迭代器","slug":"lua学习笔记——迭代器","date":"2019-12-02T08:05:00.000Z","updated":"2019-12-05T09:08:36.762Z","comments":true,"path":"2019/12/02/lua学习笔记——迭代器/","link":"","permalink":"http://yoursite.com/2019/12/02/lua学习笔记——迭代器/","excerpt":"","text":"[TOC] 定义 是一种可以让我们遍历一个集合的所有元素的代码结构。 在 lua 语言中，通常使用函数表示迭代器。每一次调用，函数就会返回集合中的下一个元素， 在没有可读取的时候返回 nil。 需要在每一次调用之后保存一些状态，这样才能在再次调用的时候返回下一个元素。 闭包为迭代器保存状态提供了一种良好的机制。 一个迭代器一般涉及两个函数：迭代器本身（闭包）和一个用于创建该迭代器的工厂。 简单的例子下面是一个顺序打印数组中所有数据的例子。 12345678910111213141516171819202122232425262728-- 迭代器工厂function values(t) local i = 0 -- 返回一个迭代器 return function() i = i + 1 return t[i] endend-- 测试数据local t = &#123;10, 20, 30&#125;-- 创建一个该测试数据的迭代器(闭包)local iter = values(t)-- 在while循环中使用这个迭代器while true do -- 调用迭代器，返回下一个数据 local element = iter() -- 当值为空时，表遍历结束，跳出循环 if element == nil then break else print(element) endend 泛型 for我们除了上面这种调用迭代器的方式之外，还可以使用泛型 for。代码如下所示： 123456-- 测试数据local t = &#123;10, 20, 30&#125;for element in values(t) do print(element)end 泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。 泛型for的基本格式如下： 123for &lt;var-list&gt; in &lt;exp-list&gt; do &lt;body&gt;end 泛型 for 的执行过程如下： 初始化。对 in 后面的表达式求值，表达式应依次返回泛型 for 需要的三个值： 迭代函数、状态常量、控制变量。 如果返回值个数不足，则用 nil 补齐。 调用迭代函数。将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数） 返回迭代结果。将迭代函数返回的值赋给变量列表。 执行循环体。 如果返回的第一个值为nil循环结束，否则执行循环体。 迭代。重新调用第二步。 注意： ：是由一个或多个变量名组成，由逗号隔开。（其实就是迭代函数的返回值） ：也是由一个或多个变量名组成，由逗号隔开。但是只会保留三个，多余的舍弃，不足的nil补足。 多状态迭代器很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。 以下实例我们使用闭包创建了自己的多状态迭代器： 123456789101112131415161718192021-- 测试数据array = &#123;\"Google\", \"Runoob\"&#125;function elementIterator (collection) local index = 0 local count = #collection -- 闭包函数 return function () index = index + 1 if index &lt;= count then -- 返回迭代器的当前元素 return collection[index] end endendfor element in elementIterator(array)do print(element)end 无状态迭代器多状态迭代器，都有一个缺点，即每个新的循环，都要创建一个新的闭包，对于大多数情况来说，这或许不会有什么问题，但是在另一些情况下，这样的开销可能会很可观。这个时候，我们就可以使用无状态迭代器。 无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。 每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。 这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。 以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方： 1234567891011-- 无状态迭代器function square(iteratorMaxCount,currentNumber) if currentNumber&lt;iteratorMaxCount then currentNumber = currentNumber+1 return currentNumber, currentNumber*currentNumber endendfor i,n in square,3,0 do print(i,n)end 按顺序遍历表的实现方案pairs 和 ipairs 的区别： pairs 遍历表，ipairs 只能遍历数组。 pairs 遍历是无序的，ipairs 是有序遍历且只能按照索引升序遍历。 接下来是按顺序遍历表的具体解决方案： 12345678910111213141516function pairsByKeys(t, f) -- 以表的key值创建一个数组 local a = &#123;&#125; for key in pairs(t) do a[#a+1] = key end -- 对key进行排序 table.sort(a, f) local i = 0 return function() i = i + 1 -- 按照 a 的顺序输出原始表的键值对 return a[i], a[i] and t[a[i]] endend 例题 编写一个迭代器 fromto，使得该循环与数值型 for 等价。 多状态迭代器实现方法： 1234567891011121314151617function fromto(t, n) local i = 0 return function() i = i + 1 if i &lt;= n then return t[i] else return nil end endend-- 使用方法local t = &#123;1, 2, 3, 4&#125;for element in fromto(t, 3) do print(element) end 无状态迭代器实现方法： 1234567891011121314151617181920212223-- 迭代函数function fromtoIter(t, i) i = i + 1 if i &lt;= t.endIndex then return t.table[i] else return nil endend-- 工厂function fromto(t, n) local temp = &#123;&#125; temp.table = t temp.endIndex = n return fromtoIter, temp, 0end-- 使用方法local t = &#123;1, 2, 3, 4&#125;for element in fromto(t, 3) do print(element) end 增加步进参数的多状态实现方案： 1234567891011121314151617function fromto(t, n, step) local i = 1 - step return function() i = i + step if i &lt;= n then return t[i] else return nil end endend-- 使用方法local t = &#123;1, 2, 3, 4&#125;for element in fromto(t, 3, 2) do print(element) end 增加步进参数的无状态实现方案： 123456789101112131415161718192021222324-- 迭代函数function fromtoIter(t, i) i = i + t.step if i &lt;= t.endIndex then return t.table[i] else return nil endend-- 工厂function fromto(t, n, step) local temp = &#123;&#125; temp.table = t temp.endIndex = n temp.step = step or 1 return fromtoIter, temp, 1 - temp.stepend-- 使用方法local t = &#123;1, 2, 3, 4&#125;for element in fromto(t, 3, 2) do print(element) end","categories":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/categories/Lua程序设计/"}],"tags":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/tags/Lua程序设计/"}]},{"title":"Lua学习笔记——时间和日期","slug":"Lua学习笔记——日期和时间","date":"2019-10-08T11:22:00.000Z","updated":"2019-12-02T07:59:08.427Z","comments":true,"path":"2019/10/08/Lua学习笔记——日期和时间/","link":"","permalink":"http://yoursite.com/2019/10/08/Lua学习笔记——日期和时间/","excerpt":"","text":"思维导图首先我们看一张思维导图： 备注： 1. 纪元：一个固定日期，在 POSIX 和 Windows 平台中这个固定日期是 Jan 01, 1970, 00:00 UTC。 2. 日期表：在 lua 中表示时间的一种方式，这个表具有以下几个重要字段：year、month、day、hour、 min、sec、wday、yday、isdst。 wday：本周中的第几天（第一天是星期日） yday：当年中的第几天 isdst：布尔类型。如果使用夏令时则为真。 例如：Sep 16,1998,23:48:10 用日期表的格式表示为：{year=1998, month=9, day=16, yday=259, wday=4, hour=23, min=48, sec=10, isdst=false} 日期表中各个参数的范围如下：（秒的最大范围是60，允许闰秒的存在。） 字段 范围 year 一整年 month 1~12 day 1~31 hour 0~23 min 0~59 sec 0~60 wday 1~7 yday 1~366 3. os.clock()：在性能测试中，可用来记录程序的运行时间。如下： 123local x = os.clock()-- do somethingprint(os.clock() - x) 实际使用1. 获取当前时间的整数表达12-- 当前时间为 2019-10-8 19:00:00print(os.time()) -- 1570532400 2. 获取当前时间的格式化表示12-- 当前时间为 2019-10-8 19:00:00print(os.date()) -- Tue Oct 8 19:00:00 2019 3. 获取指定天数之后的日期下面我们先看一个计算当前天数 40 天之后的日期的例子： 123456789101112-- 当前时间为 2019-10-8 19:00:00t = os.date(\"*t\") -- 获取当前日期print(os.date(\"%Y/%m/%d\", os.time(t))) -- 2019-10-8print(t.day, t.month) -- 8 10t.day = t.day + 40print(t.day, t.month) -- 48 10print(os.date(\"%Y/%m/%d\", os.time(t))) -- 2019-11-17 (归一化)t = os.date(\"*t\", os.time(t))print(t.day, t.month) -- 17 11 -- 2019-11-17 (归一化)t.month = t.month + 1print(t.day, t.month) -- 17 12print(os.date(\"%Y/%m/%d\", os.time(t))) -- 2019-12-17 在上面的例子中，我们看到，在加完天数之后，我们先将我们的日期表使用 os.time() 转换成整数，然后再用 os.date() 就可以做到日期的归一化显示。","categories":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/categories/Lua程序设计/"}],"tags":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/tags/Lua程序设计/"}]},{"title":"Unity中查找静态引用指定图片的预制体","slug":"Unity中查找静态引用指定图片的预制体","date":"2019-09-16T03:07:42.000Z","updated":"2019-09-16T03:09:20.840Z","comments":true,"path":"2019/09/16/Unity中查找静态引用指定图片的预制体/","link":"","permalink":"http://yoursite.com/2019/09/16/Unity中查找静态引用指定图片的预制体/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using UnityEditor;using UnityEngine;using System.Collections.Generic;using System.IO;public class SearchRefrenceEditorWindow : EditorWindow&#123; /// &lt;summary&gt; /// 查找引用 /// &lt;/summary&gt; [MenuItem(&quot;Assets/SearchRefrence&quot;)] static void SearchRefrence() &#123; SearchRefrenceEditorWindow window = (SearchRefrenceEditorWindow)EditorWindow.GetWindow(typeof(SearchRefrenceEditorWindow), false, &quot;Searching&quot;, true); window.Show(); &#125; private static Object searchObject; private List&lt;Object&gt; result = new List&lt;Object&gt;(); private void OnGUI() &#123; EditorGUILayout.BeginHorizontal(); searchObject = EditorGUILayout.ObjectField(searchObject, typeof(Object), true, GUILayout.Width(200)); if (GUILayout.Button(&quot;Search&quot;, GUILayout.Width(100))) &#123; result.Clear(); if (searchObject == null) return; string assetPath = AssetDatabase.GetAssetPath(searchObject); string assetGuid = AssetDatabase.AssetPathToGUID(assetPath); //只检查prefab string[] guids = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, new[] &#123; &quot;Assets/Res/GUI/prefabs&quot; &#125;); float length = guids.Length; for (int i = 0; i &lt; length; i++) &#123; string filePath = AssetDatabase.GUIDToAssetPath(guids[i]); if (EditorUtility.DisplayCancelableProgressBar(&quot;Checking&quot;, filePath, i / length)) &#123; break; &#125; //检查是否包含guid string content = File.ReadAllText(filePath); if (content.Contains(assetGuid)) &#123; Object fileObject = AssetDatabase.LoadAssetAtPath(filePath, typeof(Object)); result.Add(fileObject); &#125; &#125; EditorUtility.ClearProgressBar(); &#125; EditorGUILayout.EndHorizontal(); //显示结果 EditorGUILayout.BeginVertical(); for (int i = 0; i &lt; result.Count; i++) &#123; EditorGUILayout.ObjectField(result[i], typeof(Object), true, GUILayout.Width(300)); &#125; EditorGUILayout.EndHorizontal(); &#125;&#125;","categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/categories/效率工具/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://yoursite.com/tags/效率工具/"}]},{"title":"Lua学习笔记——闭包","slug":"Lua学习笔记——闭包","date":"2019-09-16T02:57:25.000Z","updated":"2019-10-08T11:22:27.972Z","comments":true,"path":"2019/09/16/Lua学习笔记——闭包/","link":"","permalink":"http://yoursite.com/2019/09/16/Lua学习笔记——闭包/","excerpt":"","text":"前言在解释闭包之前，我们先要介绍下下面几个概念。 非局部变量（UpValue） 词法定界 1. 非局部变量（UpValue）定义： 不在局部范围内定义的非全局变量。 在下面的那段代码中，变量 a 既不是函数 B( ) 的局部变量，也不是全局变量，我们称 a 是函数 B( ) 的非局部变量（即 UpValue）。 1234567function A() local a = &#123;&#125; function B() local b = a endend 2. 词法定界定义： 被嵌套的函数可以访问他外部函数中的变量。 如上面那段代码所示，正是因为词法定界的存在，我们才可以在函数 B( ) 中，访问到函数 A( ) 中的局部变量 a。 闭包定义： 一个闭包就是由该函数和与其相关的引用环境所组成的实体。闭包 = 函数 + 引用环境。 在上面的代码中，函数 A( ) 就是一个闭包，函数 B( ) 和其引用的 变量a 也是一个闭包。 我们再来看下下面这段代码 1234567function newCounter() local count = 0 return function() count = count + 1 return count endend 在上述这段代码中，函数 newCounter( ) 返回了一个匿名函数，该匿名函数又调用了 非局部变量count， 当我们调用这个函数之后，会返回一个闭包，这个闭包由该匿名函数和 非局部变量count 组成，每调用一次返回的匿名函数，count 的值都会加 1。效果如下所示 123local c1 = newCounter()c1() --&gt; 1c1() --&gt; 2 这个时候，如果我们再次调用方法 newCounter( )， 就会创建一个新的闭包。效果如下： 12345local c2 = newCounter()c2() --&gt; 1c1() --&gt; 3c2() --&gt; 2c2() --&gt; 3 总结： 闭包 = 函数 + 引用环境。 每一个闭包都是一个独立的互不干扰的个体。 从技术上讲，lua 语言只有闭包没有函数，函数本身只是闭包的一种原型。","categories":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/categories/Lua程序设计/"}],"tags":[{"name":"Lua程序设计","slug":"Lua程序设计","permalink":"http://yoursite.com/tags/Lua程序设计/"}]},{"title":"策略模式","slug":"策略模式","date":"2019-07-16T03:10:53.000Z","updated":"2019-07-18T11:04:15.499Z","comments":true,"path":"2019/07/16/策略模式/","link":"","permalink":"http://yoursite.com/2019/07/16/策略模式/","excerpt":"","text":"1. 什么是策略模式？策略模式定义了算法族，将它们分别封装起来，让它们可以相互替换。这个模式使算法独立于它的使用者。 譬如我们我们需要实现一个计算器的功能，这个计算器有加减乘除四种计算方式，一般的做法就是创建一个计算器类，然后在这个类中添加加减乘除四个方法。代码如下： 1234567public class Calculator&#123; public int Add(int num1, int num2)&#123;return num1+num2;&#125; public int Sub(int num1, int num2)&#123;return num1-num2;&#125; public int Mul(int num1, int num2)&#123;return num1*num2;&#125; public int Div(int num1, int num2)&#123;return num1/num2;&#125;&#125; 策略模式是将加减乘除分别定义成一个单独的类，当我们使用计算器的时候，动态的替换我们当前使用的算法，具体代码如下： 12345678910111213141516171819202122232425262728public interface Operation&#123; public int Operate(int num1, int num2);&#125;public class AddOperation:Operation&#123; public int Operate(int num1, int num2)&#123;return num1 + num2;&#125;&#125;public class SubOperation:Operation&#123; public int Operate(int num1, int num2)&#123;return num1 - num2;&#125;&#125;public class Calculator&#123; private Operation _curOperation; public void SetOperation(Operation o)&#123;_curOperation = o;&#125; public int Operate(int num1, num2)&#123;return _curOperation.Operate(num1, num2)&#125;&#125;// 使用方法Calculator c = new Calculator();c.SetOperation(new AddOperation());c.Operate(2, 1); // 输出 3c.SetOperation(new SubOperation());c.Operate(2, 1); // 输出 1 策略模式让我们的代码更容易扩展，如果以后需要添加其他的算法，只需要再增加一个新的类，然后实现Operation接口，不需要改动之前的任何代码。 2. 设计模式的优缺点优点： ​ 1. 遵守了开放封闭原则。扩展性良好 缺点： 策略越多，类也就会越多。 所有的算法都应该暴露出去，并且写好文档，让别人知道你已经提供了哪些策略。 ​","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"策略模式","slug":"策略模式","permalink":"http://yoursite.com/tags/策略模式/"}]}]}